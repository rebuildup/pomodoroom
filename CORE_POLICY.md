# CORE_POLICY.md — Pomodoroom 憲法

> **本文書はプロジェクト全体の最上位規範である。**
> すべてのエージェント・開発者・設計判断は、本文書の原則に従わなければならない。
> 矛盾が生じた場合、本文書が常に優先される。

---

## 1. 絶対目標

**「人間の生産性を最大化し、作業効率を極限まで高める」**

本システムの存在意義は、限られた時間の中で人間が成し遂げられるアウトプットを最大化することにある。
すべての機能と設計は、この一点に向かって収束しなければならない。

### ターゲットユーザー

**時間に縛られないフリーランス。** 常に自己管理が利益に直結する人。
上司も定時もない環境で、自律的に稼働を最適化する必要がある人間のためのシステムである。

---

## 2. 二大哲学

効率化という目標を達成するために、以下の二つのアプローチを基本戦略とする。

### 2.1 意思決定の外部化（選択コストの排除）

人間が「次は何をすべきか？」と迷う時間は、**生産性がゼロの時間**である。

- **計画・計算**を計算機（システム/AI）に外部化する
- 人間は**「実行」のみに特化**する
- 意思決定に伴う認知負荷と時間ロスを排除する

**具体原則:**
- システムは常に「次にやるべきこと」を1つだけ提示する
- 選択肢を多数提示してユーザーに選択責任を返すことは**禁止**
- タスク提案は最大2〜3件。各候補に必ず「理由（why）」を添える

### 2.2 介入による行動同期（集中の引力）

システムが弾き出した「最適解」は、人間の行動と一致して初めて効率化として結実する。

- 通知等の能動的な介入を「集中の引力」として機能させる
- 無意識の逸脱（サボりや脱線）を**物理的に阻止**する
- 人間の意識をシステムが定義したタイムスロットへと同期させる

**具体原則:**
- 通知はOSの標準通知を使用**しない**（無視できるため）
- **回避不能な独自ダイアログウインドウ**（最前面・操作必須）を使用する
- ユーザーが「着手」「完了」等のアクションを宣言するまでダイアログは消えない

---

## 3. システムアーキテクチャ原則

### 3.1 CLIファースト

> **「CLIが真実、GUIは皮」**

- すべてのビジネスロジックはRustコアライブラリ（`pomodoroom-core`）に実装する
- CLIバイナリ（`pomodoroom-cli`）から全機能を操作できる
- GUIはコアの出力を表示し、コアのAPIを呼ぶだけの薄いレイヤー
- AIエージェントはCLI経由でシステムを操作できなければならない

### 3.2 バックエンドとフロントエンドの完全分離

- バックエンド（Rustコア + CLI）はフロントエンドに一切依存しない
- フロントエンドはバックエンドのAPIを呼ぶだけ
- フロントエンドが壊れても、CLIからの操作に影響しない

### 3.3 Google Calendar = リモートデータベース

Google Calendarは単なる連携先ではなく、**リモートデータベース**として機能する。
SSoT（唯一の真実）ではなく、ローカルDBとリモートDBの**対等な双方向同期**である。

**同期モデル:**

```
┌──────────────┐         ┌──────────────────┐
│  SQLite      │ ◀─────▶ │ Google Calendar  │
│  (ローカルDB) │  双方向  │ (リモートDB)     │
│               │   同期   │                  │
└──────────────┘         └──────────────────┘
```

- **SQLite** = ローカルデータベース（メイン操作対象・オフライン動作）
- **Google Calendar** = リモートデータベース（他デバイス・プラットフォーム連携）
- 通常フロー: ローカル操作 → SQLite更新 → Google Calendarへ同期
- リモート変更時: Google Calendar → SQLiteへ反映（**リモート優先**）
- コンフリクト時: ユーザーに最小負荷の選択ダイアログを表示

**保存対象:** タスク内容（名称、メモ、ステータス）、スケジュール（時間枠）、プロジェクト情報、リファレンス — すべてのデータをGoogle Calendarイベントとして保存する。

---

## 4. タスク状態モデル

### 4.1 三層分類

| 分類 | 定義 | 数 | 旧用語 |
|------|------|-----|--------|
| **Active** | 現在実行中の作業 | **最大1つ** | 旧Anchor |
| **Wait** | 出力待ち・外部ブロック等の待機状態 | 複数 | — |
| **Floating** | 隙間時間を埋める低負荷タスク | 複数 | 旧Ambientの一部 |

**設計意図:**
- **Active** が空の瞬間＝生産性ゼロの瞬間。システムは即座に Floating を提案し、空白を埋める
- **Wait** のタスクは条件が解消され次第、Active候補として再浮上する
- **Floating** はSNS・動画への逃避を**物理的に埋める**ための武器である

### 4.2 ユーザーアクション設計原則

**ユーザーの操作負荷は極限まで最小化する。** タスクの切替を一瞬で行えるシステムを設計する。

- ユーザーが行うのは**宣言だけ**（「これをやる」「終わった」「止める」）
- 宣言は**ワンタップ/ワンクリック**で完結させる
- テキスト入力を要求する場面を最小化する
- タスク切替時に「次に何をすべきか」を考えさせない（システムが提案する）
- Active → 別タスクへの切替は、提案されたタスクを選ぶだけで完了する
- 中断・再開の操作にテキスト入力を挟まない

### 4.2 状態遷移

```
              開始              完了
  READY ─────────────▶ RUNNING ─────────────▶ DONE
    ▲                     │
    │    先送り            │  中断
    │  (優先度下げ)        ▼
    │                   PAUSED
    │                     │
    │      再開            │
    └─────────────────────┘
```

**コード上の状態とタスク分類の対応:**

| コード上の状態 | タスク分類 | 条件 |
|---|---|---|
| `running` | **Active** | 常にActive（最大1つ） |
| `paused` + 外部ブロック条件あり | **Wait** | 外部要因で進行不能 |
| `ready` + 低優先度/低エネルギー | **Floating候補** | スケジューラが割り当て |
| `ready` + 通常優先度 | Active候補 | 次のActive提案に使用 |
| `done` | 完了 | 分類から除外 |

### 4.3 操作→状態遷移マッピング

| 操作 | 遷移 | 備考 |
|------|------|------|
| 開始 | READY → RUNNING | Activeに昇格。既存のActiveは自動的にPAUSEDへ |
| 完了 | RUNNING → DONE | Activeが空になり、次タスク提案が発火 |
| 延長 | RUNNING → RUNNING | タイマーリセット。Active維持 |
| 中断 | RUNNING → PAUSED | Wait または Floating候補に降格 |
| 再開 | PAUSED → RUNNING | Activeに復帰 |
| 先送り | READY → READY | 優先度を下げて後回し |

### 4.4 コンテキストの数理モデル

コンテキスト（文脈情報）は**テキストではなく、数理モデル**として扱う。
ユーザーにテキスト入力を求めることは操作負荷であり、避けなければならない。

**コンテキストの構成要素（すべてシステムが自動で記録）:**

- タスクが持つメタデータ（タグ、分類、プロジェクト、エネルギーレベル）
- 操作履歴（開始時刻、中断回数、延長回数、先送り回数）
- タスク間の関係性（同一プロジェクト、同一タグ、依存関係）
- 時間的コンテキスト（経過時間、残り見積もり、中断からの経過時間）

再開時、システムはこれらの数理的コンテキストからタスクの「状況」を再構成し、
ユーザーに**計算された文脈情報**を提示する。ユーザーが思い出す必要はない。

---

## 5. Pressure（圧力）モデル

### 5.1 定義

**Pressure は「介入（通知）の頻度と強さを決定する動的パラメータ」である。**

```
Pressure = remaining_work − remaining_capacity
```

- `remaining_work`: READY + RUNNING タスクの見積もり合計（分）
- `remaining_capacity`: 本日の残り稼働時間 − 固定予定 − 休憩（分）

### 5.2 モード遷移

| 条件 | モード | 介入強度 |
|------|--------|----------|
| Pressure ≤ 0 | **Normal** | 通常。Floating許容。介入は控えめ |
| 0 < Pressure ≤ threshold | **Pressure** | Floating禁止。Active復帰を強く促す |
| Pressure > threshold | **Overload** | 最大介入。タスク削減・延期を提案 |

**原則:**
- モード遷移は**完全自動**。ユーザーに選ばせない
- Pressure が高い場合、Floating を許さず、Active への復帰をより強力に（かつ高頻度に）促す
- Overload 時はタスク削減の提案を積極的に行い、ユーザーの破綻を防ぐ

### 5.3 介入頻度テーブル

| モード | Active空白時の介入間隔 | ダイアログの強さ |
|--------|------------------------|------------------|
| Normal | 5分後 | ソフト（提案型） |
| Pressure | 1分後 | ミディアム（催促型） |
| Overload | 30秒後 | ハード（警告型） |

---

## 6. 通知（介入ダイアログ）の哲学

### 6.1 基本原則

- **回避不能**: 最前面に表示。最小化・無視できない
- **操作必須**: ユーザーが明示的なアクション（タスク着手、休憩宣言等）を行うまで消えない
- **文脈提示**: ダイアログは常に「なぜこの通知が出たか」「次に何をすべきか」を明示
- **独自ウインドウ**: Tauriのウインドウ機能を使用し、OSの標準通知は使わない

### 6.2 介入トリガー

| トリガー | 内容 |
|----------|------|
| タイマー完了 | 次のタスク提案 + コンテキスト再提示 |
| Active空白 | 「何もしていない」検知。Floating or Active候補を提案 |
| Pressureモード遷移 | モード変更の通知 + 推奨アクション |
| Wait解除 | 待機中タスクの再開提案 |

---

## 7. プロジェクト管理

### 7.1 プロジェクト構造

```
Project (name, defaultTags, color, deadline)
  └── Tasks (複数)
        ├── manualTags (自由入力 + 選択)
        ├── suggestedTags (承認制)
        └── effectiveTags = union(project.defaultTags, manualTags, suggestedTags)
```

### 7.2 タグシステム

タグは**自由入力**と**既存タグからの選択**の両方を許可する。

**タグの価値はテキスト名にはない。** タグの持つ意味は、そのタグが付与されたタスク群・
プロジェクト・他タスクとの関係性から数理的に導出される。

- タグ名そのものからコンテキストを判断しない
- タグの共起関係、タスク横断の関連性、プロジェクトとの紐付けから文脈を計算する
- これにより、ユーザーが独自のタグ体系を自由に構築しても、システムは適切にコンテキストを推論できる

---

## 8. 絶対禁止事項

以下の行為はプロジェクトの根本思想に反するため、いかなる理由があっても行ってはならない。

1. **「Delay」「遅延」の用語使用** → 「Pressure」を使え
2. **選択肢の過剰提示** → 次タスク候補は2〜3件まで
3. **OS標準通知の使用** → 独自ダイアログのみ
4. **フロントエンドにビジネスロジックを置く** → Rustコアに実装
5. **Google Calendar連携を「おまけ機能」扱いする** → リモートDBとして中核的に扱え
6. **ユーザーに計画を立てさせる** → システムが計画し、ユーザーは実行のみ
7. **Floating時間にユーザーを放置する** → 必ず何かを提案する
8. **コンテキストにテキスト入力を求める** → 数理モデルで自動導出せよ
9. **Pressure モードをユーザーに選ばせる** → 完全自動遷移
10. **旧用語（Anchor, Ambient, Passive）の使用** → Active, Wait, Floating を使え

---

## 9. 判断のエスカレーション規則

エージェントが判断に迷った場合、以下の順序で解決する:

1. **本文書（CORE_POLICY.md）を再読** — 原則に照らして判断
2. **AGENTS.md を参照** — 役割分担と通信規約を確認
3. **担当ドメインの仕様書を参照** — `docs/domains/*.md`
4. **CLAUDE.md を参照** — 技術的な実装詳細
5. **上記で解決しない場合** — Issue にコメントを残し、ユーザーに判断を仰ぐ

**勝手に仕様を変えてはならない。** 不明点は明示的にエスカレーションせよ。

---

## 10. ドキュメント階層と読み順

```
CLAUDE.md / AGENTS.md   ← エージェントの入口（最初に読まれる）
  └── CORE_POLICY.md     ← 憲法（必ず参照される）
        └── docs/domains/
              ├── scheduler.md  ← Scheduler Agent 仕様
              ├── ui-dialog.md  ← UI/Dialog Agent 仕様
              └── integrator.md ← Integrator Agent 仕様
```

エージェントが最初に読むのは `CLAUDE.md` または `AGENTS.md` である。
これらのドキュメントは冒頭で `CORE_POLICY.md` への参照を持ち、
エージェントを本文書（憲法）へと導く。

**読み順:** `CLAUDE.md` / `AGENTS.md`（入口）→ `CORE_POLICY.md`（原則理解）→ `docs/domains/*`（担当仕様）
